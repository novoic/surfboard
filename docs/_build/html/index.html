
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <title>Welcome to Surfboard’s documentation! &#8212; Surfboard  documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="module-surfboard.sound">
<span id="welcome-to-surfboard-s-documentation"></span><h1>Welcome to Surfboard’s documentation!<a class="headerlink" href="#module-surfboard.sound" title="Permalink to this headline">¶</a></h1>
<p>This file contains the central Waveform class of the surfboard package, and all the corresponding methods</p>
<dl class="py class">
<dt id="surfboard.sound.Waveform">
<em class="property">class </em><code class="sig-prename descclassname">surfboard.sound.</code><code class="sig-name descname">Waveform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">signal</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sample_rate</span><span class="o">=</span><span class="default_value">44100</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform" title="Permalink to this definition">¶</a></dt>
<dd><p>The central class of the package. This class instantiates with a path to a sound file and
a sample rate to load it or a signal and a sample rate. We can then use methods of this class to
compute various components.</p>
<dl class="py method">
<dt id="surfboard.sound.Waveform.bark_spectrogram">
<code class="sig-name descname">bark_spectrogram</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n_fft_seconds</span><span class="o">=</span><span class="default_value">0.04</span></em>, <em class="sig-param"><span class="n">hop_length_seconds</span><span class="o">=</span><span class="default_value">0.01</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform.bark_spectrogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the magnitude spectrum of self.waveform and arrange the frequency bins
in the Bark scale. See <a class="reference external" href="https://en.wikipedia.org/wiki/Bark_scale">https://en.wikipedia.org/wiki/Bark_scale</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_fft_seconds</strong> (<em>float</em>) – Length of the FFT window in seconds.</p></li>
<li><p><strong>hop_length_seconds</strong> (<em>float</em>) – How much the window shifts for every timestep, in seconds.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Bark spectrogram</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array, [n_bark_bands, T / hop_length]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.chroma_cens">
<code class="sig-name descname">chroma_cens</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">hop_length_seconds</span><span class="o">=</span><span class="default_value">0.01</span></em>, <em class="sig-param"><span class="n">n_chroma</span><span class="o">=</span><span class="default_value">12</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform.chroma_cens" title="Permalink to this definition">¶</a></dt>
<dd><p>See librosa.feature documentation for more details on this component. This computes
the CENS chroma variant from a waveform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hop_length_seconds</strong> (<em>float</em>) – How much the window shifts for every timestep,
in seconds.</p></li>
<li><p><strong>n_chroma</strong> (<em>int</em>) – Number of chroma bins to compute.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>CENS-chromagram</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array, [n_chroma, T / hop_length]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.chroma_cqt">
<code class="sig-name descname">chroma_cqt</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">hop_length_seconds</span><span class="o">=</span><span class="default_value">0.01</span></em>, <em class="sig-param"><span class="n">n_chroma</span><span class="o">=</span><span class="default_value">12</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform.chroma_cqt" title="Permalink to this definition">¶</a></dt>
<dd><p>See librosa.feature documentation for more details on this component. This computes
a constant-Q chromagram from a waveform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hop_length_seconds</strong> (<em>float</em>) – How much the window shifts for every timestep,
in seconds.</p></li>
<li><p><strong>n_chroma</strong> (<em>int</em>) – Number of chroma bins to compute.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Constant-Q transform mode</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array, [n_chroma, T / hop_length]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.chroma_stft">
<code class="sig-name descname">chroma_stft</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n_fft_seconds</span><span class="o">=</span><span class="default_value">0.04</span></em>, <em class="sig-param"><span class="n">hop_length_seconds</span><span class="o">=</span><span class="default_value">0.01</span></em>, <em class="sig-param"><span class="n">n_chroma</span><span class="o">=</span><span class="default_value">12</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform.chroma_stft" title="Permalink to this definition">¶</a></dt>
<dd><p>See librosa.feature documentation for more details on this component. This computes
a chromagram from a waveform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_fft_seconds</strong> (<em>float</em>) – Length of the FFT window in seconds.</p></li>
<li><p><strong>hop_length_seconds</strong> (<em>float</em>) – How much the window shifts for every timestep,
in seconds.</p></li>
<li><p><strong>n_chroma</strong> (<em>int</em>) – Number of chroma bins to compute.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The chromagram</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array, [n_chroma, T / hop_length]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.compute_components">
<code class="sig-name descname">compute_components</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">component_list</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform.compute_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute components from self.waveform and self.sample_rate using a list of strings
which identify which components to compute. You can pass in arguments to the
components (e.g. frame_length_seconds) by passing in the components as dictionaries.
For example: {‘mfcc’: {‘n_mfcc’: 26}}. See README.md for more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>component_list</strong> (<em>list of str</em><em> or </em><em>dict</em>) – The methods to be computed.
If elements are str, then the method uses default arguments.
If dict, the arguments are passed to the methods.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Dictionary mapping component names to computed components.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.crest_factor">
<code class="sig-name descname">crest_factor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">frame_length_seconds</span><span class="o">=</span><span class="default_value">0.04</span></em>, <em class="sig-param"><span class="n">hop_length_seconds</span><span class="o">=</span><span class="default_value">0.01</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform.crest_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the crest factor of this waveform, on sliding windows. This value measures the local intensity
of peaks in a waveform. Implemented as per: <a class="reference external" href="https://en.wikipedia.org/wiki/Crest_factor">https://en.wikipedia.org/wiki/Crest_factor</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frame_length_seconds</strong> (<em>float</em>) – Length of the sliding window, in seconds.</p></li>
<li><p><strong>hop_length_seconds</strong> (<em>float</em>) – How much the window shifts for every timestep,
in seconds.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Crest factor for each frame.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array, [1, T / hop_length]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.dfa">
<code class="sig-name descname">dfa</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">window_lengths</span><span class="o">=</span><span class="default_value">[64, 128, 256, 512, 1024, 2048, 4096]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform.dfa" title="Permalink to this definition">¶</a></dt>
<dd><p>See Tsanas et al, 2011:
Novel speech signal processing algorithms for high-accuracy classification of Parkinson‟s disease
Detrended Fluctuation Analysis</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>window_lengths</strong> (<em>list of int &gt; 0</em>) – List of L to use in DFA computation.
See dfa.py for more details.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The detrended fluctuation analysis alpha value.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.f0_contour">
<code class="sig-name descname">f0_contour</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">hop_length_seconds</span><span class="o">=</span><span class="default_value">0.01</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'swipe'</span></em>, <em class="sig-param"><span class="n">f0_min</span><span class="o">=</span><span class="default_value">60</span></em>, <em class="sig-param"><span class="n">f0_max</span><span class="o">=</span><span class="default_value">300</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform.f0_contour" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the F0 contour using PYSPTK: <a class="reference external" href="https://github.com/r9y9/pysptk/">https://github.com/r9y9/pysptk/</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hop_length_seconds</strong> (<em>float</em>) – Hop size argument in pysptk. Corresponds to hopsize
in the window sliding of the computation of f0. This is in seconds and gets
converted.</p></li>
<li><p><strong>method</strong> (<em>str</em>) – One of ‘swipe’ or ‘rapt’. Define which method to use for f0
calculation. See <a class="reference external" href="https://github.com/r9y9/pysptk">https://github.com/r9y9/pysptk</a></p></li>
<li><p><strong>f0_min</strong> (<em>float</em>) – minimum acceptable f0.</p></li>
<li><p><strong>f0_max</strong> (<em>float</em>) – maximum acceptable f0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>F0 contour of self.waveform. Contains unvoiced</dt><dd><p>frames.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array, [1, t1]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.f0_statistics">
<code class="sig-name descname">f0_statistics</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">hop_length_seconds</span><span class="o">=</span><span class="default_value">0.01</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'swipe'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform.f0_statistics" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the F0 mean and standard deviation of self.waveform. Note that we cannot
simply rely on using statistics applied to the f0_contour since we do not want to
include the zeros in the mean and standard deviation calculations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hop_length_seconds</strong> (<em>float</em>) – Hop size argument in pysptk. Corresponds to hopsize
in the window sliding of the computation of f0. This is in seconds and gets
converted.</p></li>
<li><p><strong>method</strong> (<em>str</em>) – One of ‘swipe’ or ‘rapt’. Define which method to use for f0
calculation. See <a class="reference external" href="https://github.com/r9y9/pysptk">https://github.com/r9y9/pysptk</a></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>Dictionary mapping:</dt><dd><p>”mean”: f0 mean of self.waveform.
“std”: f0 standard deviation of self.waveform.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.formants">
<code class="sig-name descname">formants</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform.formants" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the first four formant frequencies using LPC (see formants.py)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>Dictionary mapping {‘f1’, ‘f2’, ‘f3’, ‘f4’} to</dt><dd><p>corresponding {first, second, third, fourth} formant frequency.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.formants_slidingwindow">
<code class="sig-name descname">formants_slidingwindow</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">frame_length_seconds</span><span class="o">=</span><span class="default_value">0.04</span></em>, <em class="sig-param"><span class="n">hop_length_seconds</span><span class="o">=</span><span class="default_value">0.01</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform.formants_slidingwindow" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the first four formant frequencies using LPC (see formants.py) and
apply the metric_slidingwindow decorator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frame_length_seconds</strong> (<em>float</em>) – Length of the sliding window, in seconds.</p></li>
<li><p><strong>hop_length_seconds</strong> (<em>float</em>) – How much the window shifts for every timestep,
in seconds.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>Time series of the first four</dt><dd><p>formant frequencies computed on windows of length frame_length_seconds,
with sliding window of hop_length_seconds.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array, [4, T / hop_length]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.hnr">
<code class="sig-name descname">hnr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform.hnr" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference external" href="https://www.ncbi.nlm.nih.gov/pubmed/12512635">https://www.ncbi.nlm.nih.gov/pubmed/12512635</a> for more thorough description
of why HNR is important in the scope of healthcare.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The harmonics to noise ratio computed on self.waveform.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.intensity">
<code class="sig-name descname">intensity</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">frame_length_seconds</span><span class="o">=</span><span class="default_value">0.04</span></em>, <em class="sig-param"><span class="n">hop_length_seconds</span><span class="o">=</span><span class="default_value">0.01</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform.intensity" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a value proportional to the intensity for each frame, with a specific frame length and hop length.
Note that the intensity is proportional to the RMS amplitude squared.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frame_length_seconds</strong> (<em>float</em>) – Length of the sliding window, in seconds.</p></li>
<li><p><strong>hop_length_seconds</strong> (<em>float</em>) – How much the window shifts for every timestep,
in seconds.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Proportional intensity value for each frame.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array, [1, T / hop_length]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.jitters">
<code class="sig-name descname">jitters</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">p_floor</span><span class="o">=</span><span class="default_value">0.0001</span></em>, <em class="sig-param"><span class="n">p_ceil</span><span class="o">=</span><span class="default_value">0.02</span></em>, <em class="sig-param"><span class="n">max_p_factor</span><span class="o">=</span><span class="default_value">1.3</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform.jitters" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the jitters mathematically, according to certain conditions
given by p_floor, p_ceil and max_p_factor. See jitters.py for more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p_floor</strong> (<em>float</em>) – Minimum acceptable period.</p></li>
<li><p><strong>p_ceil</strong> (<em>float</em>) – Maximum acceptable period.</p></li>
<li><p><strong>max_p_factor</strong> (<em>float</em>) – value to use for the period factor principle</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>dictionary mapping strings to floats, with keys</dt><dd><p>”localJitter”, “localabsoluteJitter”, “rapJitter”, “ppq5Jitter”,
“ddpJitter”</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.kurtosis_slidingwindow">
<code class="sig-name descname">kurtosis_slidingwindow</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">frame_length_seconds</span><span class="o">=</span><span class="default_value">0.04</span></em>, <em class="sig-param"><span class="n">hop_length_seconds</span><span class="o">=</span><span class="default_value">0.01</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform.kurtosis_slidingwindow" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the kurtosis on frames of the waveform with a sliding
window</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frame_length_seconds</strong> (<em>float</em>) – Length of the sliding window, in seconds.</p></li>
<li><p><strong>hop_length_seconds</strong> (<em>float</em>) – How much the window shifts for every timestep,
in seconds.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Kurtosis on each sliding window.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array, [1, T / hop_length]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.log_energy">
<code class="sig-name descname">log_energy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform.log_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the log energy of self.waveform as per Abeyrante et al. 2013.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The log energy of self.waveform, computed as per the paper above.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.log_energy_slidingwindow">
<code class="sig-name descname">log_energy_slidingwindow</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">frame_length_seconds</span><span class="o">=</span><span class="default_value">0.04</span></em>, <em class="sig-param"><span class="n">hop_length_seconds</span><span class="o">=</span><span class="default_value">0.01</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform.log_energy_slidingwindow" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the log energy on frames of the waveform with a sliding
window</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frame_length_seconds</strong> (<em>float</em>) – Length of the sliding window, in seconds.</p></li>
<li><p><strong>hop_length_seconds</strong> (<em>float</em>) – How much the window shifts for every timestep,
in seconds.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Log energy on each sliding window.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array, [1, T / hop_length]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.log_melspec">
<code class="sig-name descname">log_melspec</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n_mels</span><span class="o">=</span><span class="default_value">128</span></em>, <em class="sig-param"><span class="n">n_fft_seconds</span><span class="o">=</span><span class="default_value">0.04</span></em>, <em class="sig-param"><span class="n">hop_length_seconds</span><span class="o">=</span><span class="default_value">0.01</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform.log_melspec" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a number of filter banks, this uses the librosa.feature.melspectrogram method to
compute the log melspectrogram of self.waveform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_mels</strong> (<em>int</em>) – Number of filter banks per time step in the log melspectrogram.</p></li>
<li><p><strong>n_fft_seconds</strong> (<em>float</em>) – Length of the FFT window in seconds.</p></li>
<li><p><strong>hop_length_seconds</strong> (<em>float</em>) – How much the window shifts for every timestep, in seconds.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Log mel spectrogram.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array, [n_mels, T_mels]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.loudness">
<code class="sig-name descname">loudness</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform.loudness" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the loudness of self.waveform using the pyloudnorm package.
See <a class="reference external" href="https://github.com/csteinmetz1/pyloudnorm">https://github.com/csteinmetz1/pyloudnorm</a> for more details on potential
arguments to the functions below.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The loudness of self.waveform</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.loudness_slidingwindow">
<code class="sig-name descname">loudness_slidingwindow</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">frame_length_seconds</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">hop_length_seconds</span><span class="o">=</span><span class="default_value">0.25</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform.loudness_slidingwindow" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the loudness of self.waveform over time. See self.loudness for
more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frame_length_seconds</strong> (<em>float</em>) – Length of the sliding window in seconds.</p></li>
<li><p><strong>hop_length_seconds</strong> (<em>float</em>) – How much the sliding window moves by</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The loudness on frames of self.waveform</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>[1, T / hop_length]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.lpc">
<code class="sig-name descname">lpc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">4</span></em>, <em class="sig-param"><span class="n">return_np_array</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform.lpc" title="Permalink to this definition">¶</a></dt>
<dd><p>This uses the librosa backend to get the Linear Prediction Coefficients via Burg’s
method. See librosa.core.lpc for more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>order</strong> (<em>int &gt; 0</em>) – Order of the linear filter</p></li>
<li><p><strong>return_np_array</strong> (<em>bool</em>) – If False, returns a dictionary. Otherwise a
numpy array.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Dictionary mapping ‘LPC_{i}’ to the i’th lpc coefficient,
for i = 0…order. Or: LP prediction error coefficients (np array case)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict or np.array, [order + 1, ]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.lsf">
<code class="sig-name descname">lsf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">4</span></em>, <em class="sig-param"><span class="n">return_np_array</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform.lsf" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the LPC coefficients, then convert them to LSP frequencies. The conversion is
done using <a class="reference external" href="https://github.com/cokelaer/spectrum/blob/master/src/spectrum/linear_prediction.py">https://github.com/cokelaer/spectrum/blob/master/src/spectrum/linear_prediction.py</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>order</strong> (<em>int &gt; 0</em>) – Order of the linear filter for LPC calculation</p></li>
<li><p><strong>return_np_array</strong> (<em>bool</em>) – If False, returns a dictionary. Otherwise a
numpy array.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Dictionary mapping ‘LPC_{i}’ to the
i’th lpc coefficient, for i = 0…order. Or LSP frequencies (np array case).</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict or np.array, [order, ]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.magnitude_spectrum">
<code class="sig-name descname">magnitude_spectrum</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n_fft_seconds</span><span class="o">=</span><span class="default_value">0.04</span></em>, <em class="sig-param"><span class="n">hop_length_seconds</span><span class="o">=</span><span class="default_value">0.01</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform.magnitude_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the STFT of self.waveform. This is used for further spectral analysis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_fft_seconds</strong> (<em>float</em>) – Length of the FFT window in seconds.</p></li>
<li><p><strong>hop_length_seconds</strong> (<em>float</em>) – How much the window shifts for every timestep, in seconds.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The magnitude spectrogram</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array, [n_fft / 2 + 1, T / hop_length]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.mfcc">
<code class="sig-name descname">mfcc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n_mfcc</span><span class="o">=</span><span class="default_value">13</span></em>, <em class="sig-param"><span class="n">n_fft_seconds</span><span class="o">=</span><span class="default_value">0.04</span></em>, <em class="sig-param"><span class="n">hop_length_seconds</span><span class="o">=</span><span class="default_value">0.01</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform.mfcc" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a number of MFCCs, use the librosa.feature.mfcc method to compute the correct
number of MFCCs on self.waveform and returns the array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_mfcc</strong> (<em>int</em>) – number of MFCCs to compute</p></li>
<li><p><strong>n_fft_seconds</strong> (<em>float</em>) – length of the FFT window in seconds.</p></li>
<li><p><strong>hop_length_seconds</strong> (<em>float</em>) – how much the window shifts for every timestep,
in seconds.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>MFCCs.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array, [n_mfcc, T / hop_length]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.morlet_cwt">
<code class="sig-name descname">morlet_cwt</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">widths</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform.morlet_cwt" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Morlet Continuous Wavelet Transform of self.waveform. Note that this
method returns a large matrix. Shown relevant in Vasquez-Correa et Al, 2016.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>wavelet</strong> (<em>str</em>) – Wavelet to use. Currently only support “morlet”.</p></li>
<li><p><strong>widhts</strong> (<em>None</em><em> or </em><em>list</em>) – If None, uses default of 32 evenly spaced widths
as [i * sample_rate / 500 for i in range(1, 33)]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The continuous wavelet transform</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array, [len(widths), T]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.ppe">
<code class="sig-name descname">ppe</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform.ppe" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute pitch period entropy. This is an adaptation of the following Matlab code:
<a class="reference external" href="https://github.com/Mak-Sim/Troparion/blob/5126f434b96e0c1a4a41fa99dd9148f3c959cfac/Perturbation_analysis/pitch_period_entropy.m">https://github.com/Mak-Sim/Troparion/blob/5126f434b96e0c1a4a41fa99dd9148f3c959cfac/Perturbation_analysis/pitch_period_entropy.m</a>
Note that computing the PPE relies on the existence of voiced portions in the F0 trajectory.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The pitch period entropy, as per <a class="reference external" href="http://www.maxlittle.net/students/thesis_tsanas.pdf">http://www.maxlittle.net/students/thesis_tsanas.pdf</a></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.rms">
<code class="sig-name descname">rms</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">frame_length_seconds</span><span class="o">=</span><span class="default_value">0.04</span></em>, <em class="sig-param"><span class="n">hop_length_seconds</span><span class="o">=</span><span class="default_value">0.01</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform.rms" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the root mean square value for each frame, with a specific frame length and hop length. This used
to be called RMSE, or root mean square energy in the jargon?</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frame_length_seconds</strong> (<em>float</em>) – Length of the sliding window, in seconds.</p></li>
<li><p><strong>hop_length_seconds</strong> (<em>float</em>) – How much the window shifts for every timestep,
in seconds.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>RMS value for each frame.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array, [1, T / hop_length]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.sample_rate">
<em class="property">property </em><code class="sig-name descname">sample_rate</code><a class="headerlink" href="#surfboard.sound.Waveform.sample_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Properties written in this way prevent users to assign to self.sample_rate</p>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.shannon_entropy">
<code class="sig-name descname">shannon_entropy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform.shannon_entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Shannon entropy of self.waveform,
as per <a class="reference external" href="https://ijssst.info/Vol-16/No-4/data/8258a127.pdf">https://ijssst.info/Vol-16/No-4/data/8258a127.pdf</a></p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Shannon entropy of the waveform.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.shannon_entropy_slidingwindow">
<code class="sig-name descname">shannon_entropy_slidingwindow</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">frame_length_seconds</span><span class="o">=</span><span class="default_value">0.04</span></em>, <em class="sig-param"><span class="n">hop_length_seconds</span><span class="o">=</span><span class="default_value">0.01</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform.shannon_entropy_slidingwindow" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Shannon entropy of subblocks of a waveform into a newly created time series,
as per <a class="reference external" href="https://ijssst.info/Vol-16/No-4/data/8258a127.pdf">https://ijssst.info/Vol-16/No-4/data/8258a127.pdf</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frame_length_seconds</strong> (<em>float</em>) – Length of the sliding window, in seconds.</p></li>
<li><p><strong>hop_length_seconds</strong> (<em>float</em>) – How much the window shifts for every timestep,
in seconds.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Shannon entropy for each frame</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array, [1, T / hop_length]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.shimmers">
<code class="sig-name descname">shimmers</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">max_a_factor</span><span class="o">=</span><span class="default_value">1.6</span></em>, <em class="sig-param"><span class="n">p_floor</span><span class="o">=</span><span class="default_value">0.0001</span></em>, <em class="sig-param"><span class="n">p_ceil</span><span class="o">=</span><span class="default_value">0.02</span></em>, <em class="sig-param"><span class="n">max_p_factor</span><span class="o">=</span><span class="default_value">1.3</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform.shimmers" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the shimmers mathematically, according to certain conditions
given by max_a_factor, p_floor, p_ceil and max_p_factor.
See shimmers.py for more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>max_a_factor</strong> (<em>float</em>) – Value to use for amplitude factor principle</p></li>
<li><p><strong>p_floor</strong> (<em>float</em>) – Minimum acceptable period.</p></li>
<li><p><strong>p_ceil</strong> (<em>float</em>) – Maximum acceptable period.</p></li>
<li><p><strong>max_p_factor</strong> (<em>float</em>) – value to use for the period factor principle</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>Cictionary mapping strings to floats, with keys</dt><dd><p>”localShimmer”, “localdbShimmer”, “apq3Shimmer”, “apq5Shimmer”,
“apq11Shimmer”</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.spectral_centroid">
<code class="sig-name descname">spectral_centroid</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n_fft_seconds</span><span class="o">=</span><span class="default_value">0.04</span></em>, <em class="sig-param"><span class="n">hop_length_seconds</span><span class="o">=</span><span class="default_value">0.01</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform.spectral_centroid" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute spectral centroid from magnitude spectrum. “First moment”.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_fft_seconds</strong> (<em>float</em>) – Length of the FFT window in seconds.</p></li>
<li><p><strong>hop_length_seconds</strong> (<em>float</em>) – How much the window shifts for every timestep,
in seconds.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Spectral centroid of the magnitude spectrum (first moment).</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array, [1, T / hop_length]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.spectral_entropy">
<code class="sig-name descname">spectral_entropy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n_fft_seconds</span><span class="o">=</span><span class="default_value">0.04</span></em>, <em class="sig-param"><span class="n">hop_length_seconds</span><span class="o">=</span><span class="default_value">0.01</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform.spectral_entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the magnitude spectrum, and compute the spectral entropy from that. To compute
that, simply normalize each frame of the spectrum, so that they are a probability
distribution, then compute the entropy from that.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_fft_seconds</strong> (<em>float</em>) – Length of the FFT window in seconds.</p></li>
<li><p><strong>hop_length_seconds</strong> (<em>float</em>) – How much the window shifts for every timestep,
in seconds.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The entropy of each normalized frame.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array, [1, T / hop_length]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.spectral_flatness">
<code class="sig-name descname">spectral_flatness</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n_fft_seconds</span><span class="o">=</span><span class="default_value">0.04</span></em>, <em class="sig-param"><span class="n">hop_length_seconds</span><span class="o">=</span><span class="default_value">0.01</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform.spectral_flatness" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an FFT window size and a hop length, uses the librosa feature package to compute the spectral
flatness of self.waveform. This component is a measure to quantify how “noise-like” a sound is. The closer
to 1, the closer the sound is to white noise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_fft_seconds</strong> (<em>float</em>) – Length of the FFT window in seconds.</p></li>
<li><p><strong>hop_length_seconds</strong> (<em>float</em>) – How much the window shifts for every timestep,
in seconds.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Spectral flatness vector computed over windows.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array, [1, T/hop_length]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.spectral_flux">
<code class="sig-name descname">spectral_flux</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n_fft_seconds</span><span class="o">=</span><span class="default_value">0.04</span></em>, <em class="sig-param"><span class="n">hop_length_seconds</span><span class="o">=</span><span class="default_value">0.01</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform.spectral_flux" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the magnitude spectrum, and compute the spectral flux from that. This is a
basic metric, measuring the rate of change of the spectrum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_fft_seconds</strong> (<em>float</em>) – Length of the FFT window in seconds.</p></li>
<li><p><strong>hop_length_seconds</strong> (<em>float</em>) – How much the window shifts for every timestep,
in seconds.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The spectral flux array.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array, [1, T / hop_length]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.spectral_kurtosis">
<code class="sig-name descname">spectral_kurtosis</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n_fft_seconds</span><span class="o">=</span><span class="default_value">0.04</span></em>, <em class="sig-param"><span class="n">hop_length_seconds</span><span class="o">=</span><span class="default_value">0.01</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform.spectral_kurtosis" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute spectral kurtosis from magnitude spectrum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_fft_seconds</strong> (<em>float</em>) – Length of the FFT window in seconds.</p></li>
<li><p><strong>hop_length_seconds</strong> (<em>float</em>) – How much the window shifts for every timestep,
in seconds.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Spectral kurtosis of the magnitude spectrum (fourth moment).</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array, [1, T / hop_length]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.spectral_rolloff">
<code class="sig-name descname">spectral_rolloff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">roll_percent</span><span class="o">=</span><span class="default_value">0.85</span></em>, <em class="sig-param"><span class="n">n_fft_seconds</span><span class="o">=</span><span class="default_value">0.04</span></em>, <em class="sig-param"><span class="n">hop_length_seconds</span><span class="o">=</span><span class="default_value">0.01</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform.spectral_rolloff" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an FFT window size and a hop length, uses the librosa component package to compute the spectral
roll-off of self.waveform. It is the point below which most energy of a signal is contained and is
useful in distinguishing sounds with different energy distributions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>roll_percent</strong> (<em>float</em>) – The roll-off percentage:
<a class="reference external" href="https://essentia.upf.edu/reference/streaming_RollOff.html">https://essentia.upf.edu/reference/streaming_RollOff.html</a></p></li>
<li><p><strong>n_fft_seconds</strong> (<em>float</em>) – Length of the FFT window in seconds.</p></li>
<li><p><strong>hop_length_seconds</strong> (<em>float</em>) – How much the window shifts for every timestep,
in seconds.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Spectral rolloff vector computed over windows.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array, [1, T/hop_length]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.spectral_skewness">
<code class="sig-name descname">spectral_skewness</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n_fft_seconds</span><span class="o">=</span><span class="default_value">0.04</span></em>, <em class="sig-param"><span class="n">hop_length_seconds</span><span class="o">=</span><span class="default_value">0.01</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform.spectral_skewness" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute spectral skewness from magnitude spectrum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_fft_seconds</strong> (<em>float</em>) – Length of the FFT window in seconds.</p></li>
<li><p><strong>hop_length_seconds</strong> (<em>float</em>) – How much the window shifts for every timestep,
in seconds.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Spectral skewness of the magnitude spectrum (third moment).</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array, [1, T / hop_length</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.spectral_slope">
<code class="sig-name descname">spectral_slope</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n_fft_seconds</span><span class="o">=</span><span class="default_value">0.04</span></em>, <em class="sig-param"><span class="n">hop_length_seconds</span><span class="o">=</span><span class="default_value">0.01</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform.spectral_slope" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the magnitude spectrum, and compute the spectral slope from that. This is a
basic approximation of the spectrum by a linear regression line. There is one coefficient
per timestep.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_fft_seconds</strong> (<em>float</em>) – Length of the FFT window in seconds.</p></li>
<li><p><strong>hop_length_seconds</strong> (<em>float</em>) – How much the window shifts for every timestep,
in seconds.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Linear regression slope, for every timestep.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array, [1, T / hop_length]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.spectral_spread">
<code class="sig-name descname">spectral_spread</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n_fft_seconds</span><span class="o">=</span><span class="default_value">0.04</span></em>, <em class="sig-param"><span class="n">hop_length_seconds</span><span class="o">=</span><span class="default_value">0.01</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform.spectral_spread" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute spectral spread (also spectral variance) from magnitude spectrum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_fft_seconds</strong> (<em>float</em>) – Length of the FFT window in seconds.</p></li>
<li><p><strong>hop_length_seconds</strong> (<em>float</em>) – How much the window shifts for every timestep,
in seconds.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Spectral skewness of the magnitude spectrum (second moment).</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array, [1, T / hop_length</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.waveform">
<em class="property">property </em><code class="sig-name descname">waveform</code><a class="headerlink" href="#surfboard.sound.Waveform.waveform" title="Permalink to this definition">¶</a></dt>
<dd><p>Properties written in this way prevent users to assign to self.waveform</p>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.zerocrossing">
<code class="sig-name descname">zerocrossing</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform.zerocrossing" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the zero crossing rate on self.waveform and return it as per
<a class="reference external" href="https://journals.plos.org/plosone/article/file?id=10.1371/journal.pone.0162128&amp;type=printable">https://journals.plos.org/plosone/article/file?id=10.1371/journal.pone.0162128&amp;type=printable</a>
Note: can also compute zero crossing rate as a time series – see librosa.feature.zero_crossing_rate,
and self.get_zcr_sequence.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>Keys “num_zerocrossings” and “rate” mapping to:</dt><dd><p>zerocrossing[“num_zerocrossings”]: number of zero crossings in self.waveform
zerocrossing[“rate”]: number of zero crossings divided by number of samples.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.sound.Waveform.zerocrossing_slidingwindow">
<code class="sig-name descname">zerocrossing_slidingwindow</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">frame_length_seconds</span><span class="o">=</span><span class="default_value">0.04</span></em>, <em class="sig-param"><span class="n">hop_length_seconds</span><span class="o">=</span><span class="default_value">0.01</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.sound.Waveform.zerocrossing_slidingwindow" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the zero crossing rate sequence on self.waveform and return it. This is now a sequence where every entry is
computed on frame_length samples. There is a sliding window of length hop_length.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frame_length_seconds</strong> (<em>float</em>) – Length of the sliding window, in seconds.</p></li>
<li><p><strong>hop_length_seconds</strong> (<em>float</em>) – How much the window shifts for every timestep,
in seconds.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Fraction of zero crossings for each frame.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array, [1, T / hop_length]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<span class="target" id="module-surfboard.statistics"></span><p>This file contains the class which computes statistics from numpy arrays to turn components into features.</p>
<dl class="py class">
<dt id="surfboard.statistics.Barrel">
<em class="property">class </em><code class="sig-prename descclassname">surfboard.statistics.</code><code class="sig-name descname">Barrel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">component</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.statistics.Barrel" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is used to instantiate components computed in the surfboard package.
It helps us compute statistics on these components.</p>
<dl class="py method">
<dt id="surfboard.statistics.Barrel.compute_statistics">
<code class="sig-name descname">compute_statistics</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">statistic_list</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.statistics.Barrel.compute_statistics" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Compute statistics on self.component using a list of strings which identify which</dt><dd><p>statistics to compute.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>statistic_list</strong> (<em>list of str</em>) – list of strings representing Barrel methods to
be called.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Dictionary mapping str to float.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.statistics.Barrel.first_derivative_kurtosis">
<code class="sig-name descname">first_derivative_kurtosis</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.statistics.Barrel.first_derivative_kurtosis" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the kurtosis of the first empirical derivative (delta coefficient)
on the last dimension (time).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>The kurtosis of the first delta coefficient</dt><dd><p>of each individual dimension in self.component</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.array, [n_feats, ]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.statistics.Barrel.first_derivative_mean">
<code class="sig-name descname">first_derivative_mean</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.statistics.Barrel.first_derivative_mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the mean of the first empirical derivative (delta coefficient)
on the last dimension (time).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>The mean of the first delta coefficient</dt><dd><p>of each individual dimension in self.component</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.array, [n_feats, ]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.statistics.Barrel.first_derivative_skewness">
<code class="sig-name descname">first_derivative_skewness</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.statistics.Barrel.first_derivative_skewness" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the skewness of the first empirical derivative (delta coefficient)
on the last dimension (time).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>The skewness of the first delta coefficient</dt><dd><p>of each individual dimension in self.component</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.array, [n_feats, ]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.statistics.Barrel.first_derivative_std">
<code class="sig-name descname">first_derivative_std</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.statistics.Barrel.first_derivative_std" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the std of the first empirical derivative (delta coefficient)
on the last dimension (time).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>The std of the first delta coefficient</dt><dd><p>of each individual dimension in self.component</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.array, [n_feats, ]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.statistics.Barrel.first_quartile">
<code class="sig-name descname">first_quartile</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.statistics.Barrel.first_quartile" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the first quartile on the last dimension (time).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>The first quartile of each individual</dt><dd><p>dimension in self.component</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.array, [n_feats, ]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.statistics.Barrel.get_first_derivative">
<code class="sig-name descname">get_first_derivative</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.statistics.Barrel.get_first_derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the “first derivative” of self.component.
Remember that self.component is of the shape [n_feats, T].</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>First empirical derivative.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.array, [n_feats, T - 1]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.statistics.Barrel.get_second_derivative">
<code class="sig-name descname">get_second_derivative</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.statistics.Barrel.get_second_derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the “second derivative” of self.component.
Remember that self.component is of the shape [n_feats, T].</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>second empirical derivative.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.array, [n_feats, T - 2]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.statistics.Barrel.kurtosis">
<code class="sig-name descname">kurtosis</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.statistics.Barrel.kurtosis" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the kurtosis of self.component on the last dimension (time)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>The kurtosis of each individual</dt><dd><p>dimension in self.component</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.array, [n_feats, ]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.statistics.Barrel.linear_regression_mse">
<code class="sig-name descname">linear_regression_mse</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.statistics.Barrel.linear_regression_mse" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a line to the data. Compute the MSE.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>The linear regression MSE of each</dt><dd><p>individual dimension in self.component</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.array, [n_feats, ]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.statistics.Barrel.linear_regression_offset">
<code class="sig-name descname">linear_regression_offset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.statistics.Barrel.linear_regression_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>Consider each row of self.component as a time series over which we fit a line.
Return the offset of that fitted line.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>The linear regression offset of each</dt><dd><p>individual dimension in self.component</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.array, [n_feats, ]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.statistics.Barrel.linear_regression_slope">
<code class="sig-name descname">linear_regression_slope</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.statistics.Barrel.linear_regression_slope" title="Permalink to this definition">¶</a></dt>
<dd><p>Consider each row of self.component as a time series over which we fit a line.
Return the slope of that fitted line.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>The linear regression slope of each</dt><dd><p>individual dimension in self.component</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.array, [n_feats, ]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.statistics.Barrel.max">
<code class="sig-name descname">max</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.statistics.Barrel.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the max of self.component on the last dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>The maximum of each individual dimension</dt><dd><p>in self.component</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.array, [n_feats, ]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.statistics.Barrel.mean">
<code class="sig-name descname">mean</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.statistics.Barrel.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the mean of self.component on the last dimension (time).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>The mean of each individual dimension</dt><dd><p>in self.component</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.array, [n_feats, ]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.statistics.Barrel.min">
<code class="sig-name descname">min</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.statistics.Barrel.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the min of self.component on the last dimension.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>The minimum of each individual dimension</dt><dd><p>in self.component</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.array, [n_feats, ]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.statistics.Barrel.percentile_1">
<code class="sig-name descname">percentile_1</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.statistics.Barrel.percentile_1" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the 1% percentile.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>The 1st percentile of each individual</dt><dd><p>dimension in self.component</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.array, [n_feats, ]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.statistics.Barrel.percentile_1_99_range">
<code class="sig-name descname">percentile_1_99_range</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.statistics.Barrel.percentile_1_99_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute 99% percentile and 1% percentile. Return the range.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>The 99th - 1st percentile range of each</dt><dd><p>individual dimension in self.component</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.array, [n_feats, ]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.statistics.Barrel.percentile_99">
<code class="sig-name descname">percentile_99</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.statistics.Barrel.percentile_99" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the 99% percentile.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>The 99th percentile of each individual</dt><dd><p>dimension in self.component</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.array, [n_feats, ]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.statistics.Barrel.q2_q1_range">
<code class="sig-name descname">q2_q1_range</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.statistics.Barrel.q2_q1_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute second and first quartiles. Return q2 - q1</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>The q2 - q1 range of each individual</dt><dd><p>dimension in self.component</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.array, [n_feats, ]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.statistics.Barrel.q3_q1_range">
<code class="sig-name descname">q3_q1_range</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.statistics.Barrel.q3_q1_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute third and first quartiles. Return q3 - q1</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>The q3 - q1 range of each individual</dt><dd><p>dimension in self.component</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.array, [n_feats, ]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.statistics.Barrel.q3_q2_range">
<code class="sig-name descname">q3_q2_range</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.statistics.Barrel.q3_q2_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute third and second quartiles. Return q3 - q2</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>The q3 - q2 range of each individual</dt><dd><p>dimension in self.component</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.array, [n_feats, ]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.statistics.Barrel.second_derivative_kurtosis">
<code class="sig-name descname">second_derivative_kurtosis</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.statistics.Barrel.second_derivative_kurtosis" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the kurtosis of the second empirical derivative (2nd delta coefficient)
on the last dimension (time).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>The kurtosis of the second delta coefficient</dt><dd><p>of each individual dimension in self.component</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.array, [n_feats, ]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.statistics.Barrel.second_derivative_mean">
<code class="sig-name descname">second_derivative_mean</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.statistics.Barrel.second_derivative_mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the mean of the second empirical derivative (2nd delta coefficient)
on the last dimension (time).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>The mean of the second delta coefficient</dt><dd><p>of each individual dimension in self.component</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.array, [n_feats, ]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.statistics.Barrel.second_derivative_skewness">
<code class="sig-name descname">second_derivative_skewness</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.statistics.Barrel.second_derivative_skewness" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the skewness of the second empirical derivative (2nd delta coefficient)
on the last dimension (time).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>The skewness of the second delta coefficient</dt><dd><p>of each individual dimension in self.component</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.array, [n_feats, ]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.statistics.Barrel.second_derivative_std">
<code class="sig-name descname">second_derivative_std</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.statistics.Barrel.second_derivative_std" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the std of the second empirical derivative (2nd delta coefficient)
on the last dimension (time).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>The std of the second delta coefficient</dt><dd><p>of each individual dimension in self.component</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.array, [n_feats, ]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.statistics.Barrel.second_quartile">
<code class="sig-name descname">second_quartile</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.statistics.Barrel.second_quartile" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the second quartile on the last dimension (time). Same
as the median.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>The second quartile of each individual</dt><dd><p>dimension in self.component (same as the median)</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.array, [n_feats, ]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.statistics.Barrel.skewness">
<code class="sig-name descname">skewness</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.statistics.Barrel.skewness" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the skewness of self.component on the last dimension (time)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>The skewness of each individual</dt><dd><p>dimension in self.component</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.array, [n_feats, ]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.statistics.Barrel.std">
<code class="sig-name descname">std</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.statistics.Barrel.std" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the standard deviation of self.component on the last dimension
(time).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>The standard deviation of each individual</dt><dd><p>dimension in self.component</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.array, [n_feats, ]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="surfboard.statistics.Barrel.third_quartile">
<code class="sig-name descname">third_quartile</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.statistics.Barrel.third_quartile" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the third quartile on the last dimension (time)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>The third quartile of each individual</dt><dd><p>dimension in self.component</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.array, [n_feats, ]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<span class="target" id="module-surfboard.feature_extraction"></span><p>This file contains functions to compute features.</p>
<dl class="py function">
<dt id="surfboard.feature_extraction.extract_features">
<code class="sig-prename descclassname">surfboard.feature_extraction.</code><code class="sig-name descname">extract_features</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">waveforms</span></em>, <em class="sig-param"><span class="n">components_list</span></em>, <em class="sig-param"><span class="n">statistics_list</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.feature_extraction.extract_features" title="Permalink to this definition">¶</a></dt>
<dd><p>This is an important function. Given a list of Waveform objects, a list of
Waveform methods in the form of strings and a list of Barrel methods in the
form of strings, compute the time-independent features resulting. This function
does multiprocessing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>waveforms</strong> (<em>list of Waveform</em>) – This is a list of waveform objects</p></li>
<li><p><strong>components_list</strong> (<em>list of str/dict</em>) – This is a list of the methods which
should be applied to all the waveform objects in waveforms. If a dict,
this also contains arguments to the sound.Waveform methods.</p></li>
<li><p><strong>statistics_list</strong> (<em>list of str</em>) – This is a list of the methods which
should be applied to all the time-dependent features computed
from the waveforms.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>pandas dataframe where every row corresponds</dt><dd><p>to features extracted for one of the waveforms and columns
represent individual features.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas DataFrame</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="surfboard.feature_extraction.extract_features_from_paths">
<code class="sig-prename descclassname">surfboard.feature_extraction.</code><code class="sig-name descname">extract_features_from_paths</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">paths</span></em>, <em class="sig-param"><span class="n">components_list</span></em>, <em class="sig-param"><span class="n">statistics_list</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sample_rate</span><span class="o">=</span><span class="default_value">44100</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.feature_extraction.extract_features_from_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Function which loads waveforms, computes the components and statistics and returns them,
without the need to store the waveforms in memory. This is to minimize the memory footprint
when running over multiple files.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>paths</strong> (<em>list of str</em>) – .wav to compute</p></li>
<li><p><strong>components_list</strong> (<em>list of str/dict</em>) – This is a list of the methods which
should be applied to all the waveform objects in waveforms. If a dict,
this also contains arguments to the sound.Waveform methods.</p></li>
<li><p><strong>statistics_list</strong> (<em>list of str</em>) – This is a list of the methods which
should be applied to all the time-dependent features computed
from the waveforms.</p></li>
<li><p><strong>sample_rate</strong> (<em>int &gt; 0</em>) – sampling rate to load the waveforms</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>pandas dataframe where every row corresponds</dt><dd><p>to features extracted for one of the waveforms and columns
represent individual features.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas DataFrame</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="surfboard.feature_extraction.extract_features_from_waveform">
<code class="sig-prename descclassname">surfboard.feature_extraction.</code><code class="sig-name descname">extract_features_from_waveform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">components_list</span></em>, <em class="sig-param"><span class="n">statistics_list</span></em>, <em class="sig-param"><span class="n">waveform</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.feature_extraction.extract_features_from_waveform" title="Permalink to this definition">¶</a></dt>
<dd><p>Given one waveform, a list of components and statistics, extract the
features from the waveform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>components_list</strong> (<em>list of str</em><em> or </em><em>dict</em>) – This is a list of the methods which
should be applied to all the waveform objects in waveforms. If a dict,
this also contains arguments to the sound.Waveform methods.</p></li>
<li><p><strong>statistics_list</strong> (<em>list of str</em>) – This is a list of the methods which
should be applied to all the “time-dependent” components computed
from the waveforms.</p></li>
<li><p><strong>waveform</strong> (<a class="reference internal" href="#surfboard.sound.Waveform" title="surfboard.sound.Waveform"><em>Waveform</em></a>) – the waveform object to extract components from.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>Dictionary mapping names to numerical components extracted</dt><dd><p>for this waveform.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="surfboard.feature_extraction.load_waveforms_from_paths">
<code class="sig-prename descclassname">surfboard.feature_extraction.</code><code class="sig-name descname">load_waveforms_from_paths</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">paths</span></em>, <em class="sig-param"><span class="n">sample_rate</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.feature_extraction.load_waveforms_from_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads waveforms from paths using multiprocessing</p>
</dd></dl>

<span class="target" id="module-surfboard.feature_extraction_multiprocessing"></span><p>This file contains functions to compute features with multiprocessing.</p>
<dl class="py function">
<dt id="surfboard.feature_extraction_multiprocessing.extract_features">
<code class="sig-prename descclassname">surfboard.feature_extraction_multiprocessing.</code><code class="sig-name descname">extract_features</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">waveforms</span></em>, <em class="sig-param"><span class="n">components_list</span></em>, <em class="sig-param"><span class="n">statistics_list</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">num_proc</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.feature_extraction_multiprocessing.extract_features" title="Permalink to this definition">¶</a></dt>
<dd><p>This is an important function. Given a list of Waveform objects, a list of
Waveform methods in the form of strings and a list of Barrel methods in the
form of strings, compute the time-independent features resulting. This function
does multiprocessing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>waveforms</strong> (<em>list of Waveform</em>) – This is a list of waveform objects</p></li>
<li><p><strong>components_list</strong> (<em>list of str</em><em> or </em><em>dict</em>) – This is a list of the methods which
should be applied to all the waveform objects in waveforms. If a dict,
this also contains arguments to the sound.Waveform methods.</p></li>
<li><p><strong>statistics_list</strong> (<em>list of str</em>) – This is a list of the methods which
should be applied to all the “time-dependent” features computed
from the waveforms.</p></li>
<li><p><strong>num_proc</strong> (<em>int &gt;= 1</em>) – The number of parallel processes to run</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>pandas dataframe where every row corresponds</dt><dd><p>to features extracted for one of the waveforms and columns
represent individual features.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas DataFrame</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="surfboard.feature_extraction_multiprocessing.extract_features_from_path">
<code class="sig-prename descclassname">surfboard.feature_extraction_multiprocessing.</code><code class="sig-name descname">extract_features_from_path</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">components_list</span></em>, <em class="sig-param"><span class="n">statistics_list</span></em>, <em class="sig-param"><span class="n">sample_rate</span></em>, <em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.feature_extraction_multiprocessing.extract_features_from_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Function which loads a waveform, computes the components and statistics and returns them,
without the need to store the waveforms in memory. This is to prevent accumulating too
much memory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>components_list</strong> (<em>list of str/dict</em>) – This is a list of the methods which
should be applied to all the waveform objects in waveforms. If a dict,
this also contains arguments to the sound.Waveform methods.</p></li>
<li><p><strong>statistics_list</strong> (<em>list of str</em>) – This is a list of the methods which
should be applied to all the “time-dependent” features computed
from the waveforms.</p></li>
<li><p><strong>sample_rate</strong> (<em>int &gt; 0</em>) – sampling rate to load the waveforms</p></li>
<li><p><strong>path</strong> (<em>str</em>) – path to audio file to extract features from</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Dictionary mapping feature names to values.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="surfboard.feature_extraction_multiprocessing.extract_features_from_paths">
<code class="sig-prename descclassname">surfboard.feature_extraction_multiprocessing.</code><code class="sig-name descname">extract_features_from_paths</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">paths</span></em>, <em class="sig-param"><span class="n">components_list</span></em>, <em class="sig-param"><span class="n">statistics_list</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sample_rate</span><span class="o">=</span><span class="default_value">44100</span></em>, <em class="sig-param"><span class="n">num_proc</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.feature_extraction_multiprocessing.extract_features_from_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Function which loads waveforms, computes the features and statistics and returns them,
without the need to store the waveforms in memory. This is to prevent accumulating too
much memory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>paths</strong> (<em>list of str</em>) – .wav to compute</p></li>
<li><p><strong>components_list</strong> (<em>list of str</em><em> or </em><em>dict</em>) – This is a list of the methods which
should be applied to all the waveform objects in waveforms. If a dict,
this also contains arguments to the sound.Waveform methods.</p></li>
<li><p><strong>statistics_list</strong> (<em>list of str</em>) – This is a list of the methods which
should be applied to all the “time-dependent” features computed
from the waveforms.</p></li>
<li><p><strong>sample_rate</strong> (<em>int &gt; 0</em>) – sampling rate to load the waveforms</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>pandas dataframe where every row corresponds</dt><dd><p>to features extracted for one of the waveforms and columns
represent individual features.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas DataFrame</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="surfboard.feature_extraction_multiprocessing.load_waveform_from_path">
<code class="sig-prename descclassname">surfboard.feature_extraction_multiprocessing.</code><code class="sig-name descname">load_waveform_from_path</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sample_rate</span></em>, <em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.feature_extraction_multiprocessing.load_waveform_from_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to access constructor with Pool</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sample_rate</strong> (<em>int</em>) – The sample rate to load the Waveform object</p></li>
<li><p><strong>path</strong> (<em>str</em>) – The path to the audio file to load</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The loaded Waveform object</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#surfboard.sound.Waveform" title="surfboard.sound.Waveform">Waveform</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="surfboard.feature_extraction_multiprocessing.load_waveforms_from_paths">
<code class="sig-prename descclassname">surfboard.feature_extraction_multiprocessing.</code><code class="sig-name descname">load_waveforms_from_paths</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">paths</span></em>, <em class="sig-param"><span class="n">sample_rate</span></em>, <em class="sig-param"><span class="n">num_proc</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.feature_extraction_multiprocessing.load_waveforms_from_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads waveforms from paths using multiprocessing</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>paths</strong> (<em>list of str</em>) – A list of paths to audio files</p></li>
<li><p><strong>sample_rate</strong> (<em>int</em>) – The sample rate to load the audio files</p></li>
<li><p><strong>num_proc</strong> (<em>int &gt;= 1</em>) – The number of parallel processes to run</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>List of loaded Waveform objects</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of Waveform</p>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-surfboard.hnr"></span><p>This function is inspired by the Speech Analysis repository at
<a class="reference external" href="https://github.com/brookemosby/Speech_Analysis">https://github.com/brookemosby/Speech_Analysis</a></p>
<dl class="py function">
<dt id="surfboard.hnr.get_harmonics_to_noise_ratio">
<code class="sig-prename descclassname">surfboard.hnr.</code><code class="sig-name descname">get_harmonics_to_noise_ratio</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">waveform</span></em>, <em class="sig-param"><span class="n">sample_rate</span></em>, <em class="sig-param"><span class="n">min_pitch</span><span class="o">=</span><span class="default_value">75.0</span></em>, <em class="sig-param"><span class="n">silence_threshold</span><span class="o">=</span><span class="default_value">0.1</span></em>, <em class="sig-param"><span class="n">periods_per_window</span><span class="o">=</span><span class="default_value">4.5</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.hnr.get_harmonics_to_noise_ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a waveform, its sample rate, some conditions for voiced and unvoiced
frames (including min pitch and silence threshold), and a “periods per window”
argument, compute the harmonics to noise ratio. This is a good measure of
voice quality and is an important metric in cognitively impaired patients.
Compute the mean hnr_vector: harmonics to noise ratio.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>waveform</strong> (<em>np.array</em><em>, </em><em>[</em><em>T</em><em>, </em><em>]</em>) – waveform signal</p></li>
<li><p><strong>sample_rate</strong> (<em>int &gt; 0</em>) – sampling rate of the waveform</p></li>
<li><p><strong>min_pitch</strong> (<em>float &gt; 0</em>) – minimum acceptable pitch. converts to
maximum acceptable period.</p></li>
<li><p><strong>silence_threshold</strong> (<em>1 &gt;= float &gt;= 0</em>) – needs to be in [0, 1]. Below this
amplitude, does not consider frames.</p></li>
<li><p><strong>periods_per_window</strong> (<em>float &gt; 0</em>) – 4.5 is best for speech.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>Harmonics to noise ratio of the entire considered</dt><dd><p>waveform.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-surfboard.jitters"></span><p>This file contains all the functions needed to compute the jitters of a waveform.</p>
<dl class="py function">
<dt id="surfboard.jitters.get_ddp_jitter">
<code class="sig-prename descclassname">surfboard.jitters.</code><code class="sig-name descname">get_ddp_jitter</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">frequencies</span></em>, <em class="sig-param"><span class="n">p_floor</span></em>, <em class="sig-param"><span class="n">p_ceil</span></em>, <em class="sig-param"><span class="n">max_p_factor</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.jitters.get_ddp_jitter" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a sequence of frequencies, and some period conditions,
compute the ddp jitter, as per
<a class="reference external" href="http://www.fon.hum.uva.nl/praat/manual/PointProcess__Get_jitter__ddp____.html">http://www.fon.hum.uva.nl/praat/manual/PointProcess__Get_jitter__ddp____.html</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frequencies</strong> (<em>sequence</em><em>, </em><em>eg list</em><em>, </em><em>of floats</em>) – sequence of estimated frequencies</p></li>
<li><p><strong>p_floor</strong> (<em>float</em>) – minimum acceptable period.</p></li>
<li><p><strong>p_ceil</strong> (<em>float</em>) – maximum acceptable period.</p></li>
<li><p><strong>max_p_factor</strong> (<em>float</em>) – value to use for the period factor principle</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the ddp jitter.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="surfboard.jitters.get_jitters">
<code class="sig-prename descclassname">surfboard.jitters.</code><code class="sig-name descname">get_jitters</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">f0_contour</span></em>, <em class="sig-param"><span class="n">p_floor</span><span class="o">=</span><span class="default_value">0.0001</span></em>, <em class="sig-param"><span class="n">p_ceil</span><span class="o">=</span><span class="default_value">0.02</span></em>, <em class="sig-param"><span class="n">max_p_factor</span><span class="o">=</span><span class="default_value">1.3</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.jitters.get_jitters" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the jitters mathematically, according to certain conditions
given by p_floor, p_ceil and max_p_factor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f0_contour</strong> (<em>np.array</em><em> [</em><em>T / hop_length</em><em>, </em><em>]</em>) – the fundamental frequency contour.</p></li>
<li><p><strong>p_floor</strong> (<em>float</em>) – minimum acceptable period.</p></li>
<li><p><strong>p_ceil</strong> (<em>float</em>) – maximum acceptable period.</p></li>
<li><p><strong>max_p_factor</strong> (<em>float</em>) – value to use for the period factor principle</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>Dictionary mapping strings to floats, with keys</dt><dd><p>”localJitter”, “localabsoluteJitter”, “rapJitter”, “ppq5Jitter”,
“ddpJitter”</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="surfboard.jitters.get_local_absolute_jitter">
<code class="sig-prename descclassname">surfboard.jitters.</code><code class="sig-name descname">get_local_absolute_jitter</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">frequencies</span></em>, <em class="sig-param"><span class="n">p_floor</span></em>, <em class="sig-param"><span class="n">p_ceil</span></em>, <em class="sig-param"><span class="n">max_p_factor</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.jitters.get_local_absolute_jitter" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a sequence of frequencies, and some period conditions,
compute the local absolute jitter, as per
<a class="reference external" href="https://royalsocietypublishing.org/action/downloadSupplement?doi=10.1098%2Frsif.2010.0456&amp;file=rsif20100456supp1.pdf">https://royalsocietypublishing.org/action/downloadSupplement?doi=10.1098%2Frsif.2010.0456&amp;file=rsif20100456supp1.pdf</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frequencies</strong> (<em>sequence</em><em>, </em><em>eg list</em><em>, </em><em>of floats</em>) – sequence of estimated frequencies</p></li>
<li><p><strong>p_floor</strong> (<em>float</em>) – minimum acceptable period.</p></li>
<li><p><strong>p_ceil</strong> (<em>float</em>) – maximum acceptable period.</p></li>
<li><p><strong>max_p_factor</strong> (<em>float</em>) – value to use for the period factor principle</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the local absolute jitter.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="surfboard.jitters.get_local_jitter">
<code class="sig-prename descclassname">surfboard.jitters.</code><code class="sig-name descname">get_local_jitter</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">frequencies</span></em>, <em class="sig-param"><span class="n">p_floor</span></em>, <em class="sig-param"><span class="n">p_ceil</span></em>, <em class="sig-param"><span class="n">max_p_factor</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.jitters.get_local_jitter" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a sequence of frequencies, and some period conditions, compute the local
jitter, as per <a class="reference external" href="https://royalsocietypublishing.org/action/downloadSupplement?doi=10.1098%2Frsif.2010.0456&amp;file=rsif20100456supp1.pdf">https://royalsocietypublishing.org/action/downloadSupplement?doi=10.1098%2Frsif.2010.0456&amp;file=rsif20100456supp1.pdf</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frequencies</strong> (<em>sequence</em><em>, </em><em>eg list</em><em>, </em><em>of floats</em>) – sequence of estimated frequencies</p></li>
<li><p><strong>p_floor</strong> (<em>float</em>) – minimum acceptable period.</p></li>
<li><p><strong>p_ceil</strong> (<em>float</em>) – maximum acceptable period.</p></li>
<li><p><strong>max_p_factor</strong> (<em>float</em>) – value to use for the period factor principle</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the local jitter.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="surfboard.jitters.get_mean_period">
<code class="sig-prename descclassname">surfboard.jitters.</code><code class="sig-name descname">get_mean_period</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">frequencies</span></em>, <em class="sig-param"><span class="n">p_floor</span></em>, <em class="sig-param"><span class="n">p_ceil</span></em>, <em class="sig-param"><span class="n">max_p_factor</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.jitters.get_mean_period" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a sequence of frequencies, passes these through the validation phase,
then computes the mean of the remaining periods. Note period = 1/f.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frequencies</strong> (<em>sequence</em><em>, </em><em>eg list</em><em>, </em><em>of floats</em>) – sequence of frequencies</p></li>
<li><p><strong>p_floor</strong> (<em>float</em>) – minimum acceptable period.</p></li>
<li><p><strong>p_ceil</strong> (<em>float</em>) – maximum acceptable period.</p></li>
<li><p><strong>max_p_factor</strong> (<em>float</em>) – value to use for the period factor principle</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The mean of the acceptable periods.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="surfboard.jitters.get_ppq5_jitter">
<code class="sig-prename descclassname">surfboard.jitters.</code><code class="sig-name descname">get_ppq5_jitter</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">frequencies</span></em>, <em class="sig-param"><span class="n">p_floor</span></em>, <em class="sig-param"><span class="n">p_ceil</span></em>, <em class="sig-param"><span class="n">max_p_factor</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.jitters.get_ppq5_jitter" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a sequence of frequencies, and some period conditions,
compute the ppq5 jitter, as per
<a class="reference external" href="https://royalsocietypublishing.org/action/downloadSupplement?doi=10.1098%2Frsif.2010.0456&amp;file=rsif20100456supp1.pdf">https://royalsocietypublishing.org/action/downloadSupplement?doi=10.1098%2Frsif.2010.0456&amp;file=rsif20100456supp1.pdf</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frequencies</strong> (<em>sequence</em><em>, </em><em>eg list</em><em>, </em><em>of floats</em>) – sequence of estimated frequencies</p></li>
<li><p><strong>p_floor</strong> (<em>float</em>) – minimum acceptable period.</p></li>
<li><p><strong>p_ceil</strong> (<em>float</em>) – maximum acceptable period.</p></li>
<li><p><strong>max_p_factor</strong> (<em>float</em>) – value to use for the period factor principle</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the ppq5 jitter.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="surfboard.jitters.get_rap_jitter">
<code class="sig-prename descclassname">surfboard.jitters.</code><code class="sig-name descname">get_rap_jitter</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">frequencies</span></em>, <em class="sig-param"><span class="n">p_floor</span></em>, <em class="sig-param"><span class="n">p_ceil</span></em>, <em class="sig-param"><span class="n">max_p_factor</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.jitters.get_rap_jitter" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a sequence of frequencies, and some period conditions,
compute the rap jitter, as per
<a class="reference external" href="https://royalsocietypublishing.org/action/downloadSupplement?doi=10.1098%2Frsif.2010.0456&amp;file=rsif20100456supp1.pdf">https://royalsocietypublishing.org/action/downloadSupplement?doi=10.1098%2Frsif.2010.0456&amp;file=rsif20100456supp1.pdf</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frequencies</strong> (<em>sequence</em><em>, </em><em>eg list</em><em>, </em><em>of floats</em>) – sequence of estimated frequencies</p></li>
<li><p><strong>p_floor</strong> (<em>float</em>) – minimum acceptable period.</p></li>
<li><p><strong>p_ceil</strong> (<em>float</em>) – maximum acceptable period.</p></li>
<li><p><strong>max_p_factor</strong> (<em>float</em>) – value to use for the period factor principle</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the rap jitter.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="surfboard.jitters.validate_frequencies">
<code class="sig-prename descclassname">surfboard.jitters.</code><code class="sig-name descname">validate_frequencies</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">frequencies</span></em>, <em class="sig-param"><span class="n">p_floor</span></em>, <em class="sig-param"><span class="n">p_ceil</span></em>, <em class="sig-param"><span class="n">max_p_factor</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.jitters.validate_frequencies" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a sequence of frequencies, [f1, f2, …, fn], a minimum period,
maximum period, and maximum period factor, first remove all frequencies computed as 0.
Then, if periods are the inverse frequencies, this function returns
True if the sequence of periods satisfies the conditions, otherwise
returns False. In order to satisfy the maximum period factor, the periods
have to satisfy pi / pi+1 &lt; max_p_factor and pi+1 / pi &lt; max_p_factor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frequencies</strong> (<em>sequence</em><em>, </em><em>eg list</em><em>, </em><em>of floats</em>) – sequence of frequencies == 1 / period.</p></li>
<li><p><strong>p_floor</strong> (<em>float</em>) – minimum acceptable period.</p></li>
<li><p><strong>p_ceil</strong> (<em>float</em>) – maximum acceptable period.</p></li>
<li><p><strong>max_p_factor</strong> (<em>float</em>) – value to use for the period factor principle</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if the conditions are met, False otherwise.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-surfboard.shimmers"></span><p>This file contains all the functions needed to compute the shimmers of a waveform.</p>
<dl class="py function">
<dt id="surfboard.shimmers.get_apq_shimmer">
<code class="sig-prename descclassname">surfboard.shimmers.</code><code class="sig-name descname">get_apq_shimmer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">amplitudes</span></em>, <em class="sig-param"><span class="n">frequencies</span></em>, <em class="sig-param"><span class="n">max_a_factor</span></em>, <em class="sig-param"><span class="n">p_floor</span></em>, <em class="sig-param"><span class="n">p_ceil</span></em>, <em class="sig-param"><span class="n">max_p_factor</span></em>, <em class="sig-param"><span class="n">apq_no</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.shimmers.get_apq_shimmer" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of amplitudes, returns the apq{apq_no}Shimmer as per
<a class="reference external" href="https://royalsocietypublishing.org/action/downloadSupplement?doi=10.1098%2Frsif.2010.0456&amp;file=rsif20100456supp1.pdf">https://royalsocietypublishing.org/action/downloadSupplement?doi=10.1098%2Frsif.2010.0456&amp;file=rsif20100456supp1.pdf</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>amplitudes</strong> (<em>list of floats</em>) – The list of peak amplitudes in each frame.</p></li>
<li><p><strong>max_a_factor</strong> (<em>float</em>) – The maximum A factor to validate amplitudes. See
validate_amplitudes().</p></li>
<li><p><strong>apq_no</strong> (<em>int</em>) – an odd number which corresponds to the number of neighbors
used to compute the shimmer.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>The apqShimmer computed over this sequence of amplitudes</dt><dd><p>with this APQ number.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="surfboard.shimmers.get_local_db_shimmer">
<code class="sig-prename descclassname">surfboard.shimmers.</code><code class="sig-name descname">get_local_db_shimmer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">amplitudes</span></em>, <em class="sig-param"><span class="n">frequencies</span></em>, <em class="sig-param"><span class="n">max_a_factor</span></em>, <em class="sig-param"><span class="n">p_floor</span></em>, <em class="sig-param"><span class="n">p_ceil</span></em>, <em class="sig-param"><span class="n">max_p_factor</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.shimmers.get_local_db_shimmer" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of amplitudes, returns the localdbShimmer as per
<a class="reference external" href="https://royalsocietypublishing.org/action/downloadSupplement?doi=10.1098%2Frsif.2010.0456&amp;file=rsif20100456supp1.pdf">https://royalsocietypublishing.org/action/downloadSupplement?doi=10.1098%2Frsif.2010.0456&amp;file=rsif20100456supp1.pdf</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>amplitudes</strong> (<em>list of floats</em>) – The list of peak amplitudes in each frame.</p></li>
<li><p><strong>max_a_factor</strong> (<em>float</em>) – The maximum A factor to validate amplitudes. See
validate_amplitudes().</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The local DB shimmer computed over this sequence of amplitudes.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="surfboard.shimmers.get_local_shimmer">
<code class="sig-prename descclassname">surfboard.shimmers.</code><code class="sig-name descname">get_local_shimmer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">amplitudes</span></em>, <em class="sig-param"><span class="n">frequencies</span></em>, <em class="sig-param"><span class="n">max_a_factor</span></em>, <em class="sig-param"><span class="n">p_floor</span></em>, <em class="sig-param"><span class="n">p_ceil</span></em>, <em class="sig-param"><span class="n">max_p_factor</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.shimmers.get_local_shimmer" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of amplitudes, returns the localShimmer as per
<a class="reference external" href="https://royalsocietypublishing.org/action/downloadSupplement?doi=10.1098%2Frsif.2010.0456&amp;file=rsif20100456supp1.pdf">https://royalsocietypublishing.org/action/downloadSupplement?doi=10.1098%2Frsif.2010.0456&amp;file=rsif20100456supp1.pdf</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>amplitudes</strong> (<em>list of floats</em>) – The list of peak amplitudes in each frame.</p></li>
<li><p><strong>max_a_factor</strong> (<em>float</em>) – The maximum A factor to validate amplitudes. See
validate_amplitudes().</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The local shimmer computed over this sequence of amplitudes.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="surfboard.shimmers.get_shimmers">
<code class="sig-prename descclassname">surfboard.shimmers.</code><code class="sig-name descname">get_shimmers</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">waveform</span></em>, <em class="sig-param"><span class="n">sample_rate</span></em>, <em class="sig-param"><span class="n">f0_contour</span></em>, <em class="sig-param"><span class="n">max_a_factor</span><span class="o">=</span><span class="default_value">1.6</span></em>, <em class="sig-param"><span class="n">p_floor</span><span class="o">=</span><span class="default_value">0.0001</span></em>, <em class="sig-param"><span class="n">p_ceil</span><span class="o">=</span><span class="default_value">0.02</span></em>, <em class="sig-param"><span class="n">max_p_factor</span><span class="o">=</span><span class="default_value">1.3</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.shimmers.get_shimmers" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute five different types of shimmers using functions defined above.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>waveform</strong> (<em>np.array</em><em>, </em><em>[</em><em>T</em><em>, </em><em>]</em>) – waveform over which to compute shimmers</p></li>
<li><p><strong>sample_rate</strong> (<em>int</em>) – sampling rate of waveform.</p></li>
<li><p><strong>f0_contour</strong> (<em>np.array</em><em>, </em><em>[</em><em>T / hop_length</em><em>, </em><em>]</em>) – the fundamental frequency contour.</p></li>
<li><p><strong>max_a_factor</strong> (<em>float</em>) – value to use for amplitude factor principle</p></li>
<li><p><strong>p_floor</strong> (<em>float</em>) – minimum acceptable period.</p></li>
<li><p><strong>p_ceil</strong> (<em>float</em>) – maximum acceptable period.</p></li>
<li><p><strong>max_p_factor</strong> (<em>float</em>) – value to use for the period factor principle</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>Dictionary mapping strings to floats, with keys</dt><dd><p>”localShimmer”, “localdbShimmer”, “apq3Shimmer”, “apq5Shimmer”,
“apq11Shimmer”</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="surfboard.shimmers.validate_amplitudes">
<code class="sig-prename descclassname">surfboard.shimmers.</code><code class="sig-name descname">validate_amplitudes</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">amplitudes</span></em>, <em class="sig-param"><span class="n">frequencies</span></em>, <em class="sig-param"><span class="n">max_a_factor</span></em>, <em class="sig-param"><span class="n">p_floor</span></em>, <em class="sig-param"><span class="n">p_ceil</span></em>, <em class="sig-param"><span class="n">max_p_factor</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.shimmers.validate_amplitudes" title="Permalink to this definition">¶</a></dt>
<dd><p>First check that frequencies corresponding to this set of amplitudes are valid. Then
Returns True if this set of amplitudes is validated as per the maximum
amplitude factor principle, i.e. if amplitudes = [a1, a2, … , an], this
functions returns false if any two successive amplitudes alpha, beta satisfy
alpha / beta &gt; max_a_factor or beta / alpha &gt; max_a_factor. False otherwise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>amplitudes</strong> (<em>list</em>) – ordered list of amplitudes to run by this principle.</p></li>
<li><p><strong>frequencies</strong> (<em>sequence</em><em>, </em><em>eg list</em><em>, </em><em>of floats</em>) – sequence of frequencies == 1 / period.</p></li>
<li><p><strong>max_a_factor</strong> (<em>float</em>) – the threshold to run the principle.</p></li>
<li><p><strong>p_floor</strong> (<em>float</em>) – minimum acceptable period.</p></li>
<li><p><strong>p_ceil</strong> (<em>float</em>) – maximum acceptable period.</p></li>
<li><p><strong>max_p_factor</strong> (<em>float</em>) – value to use for the period factor principle</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>True if this set of amplitudes satisifies the principle</dt><dd><p>and this set of frequencies satisfies the period condition,
False otherwise.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-surfboard.dfa"></span><dl class="py function">
<dt id="surfboard.dfa.get_deviation_for_dfa">
<code class="sig-prename descclassname">surfboard.dfa.</code><code class="sig-name descname">get_deviation_for_dfa</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">signal</span></em>, <em class="sig-param"><span class="n">window_length</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.dfa.get_deviation_for_dfa" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a signal, compute the trend value for one window length, as per
<a class="reference external" href="https://link.springer.com/article/10.1186/1475-925X-6-23">https://link.springer.com/article/10.1186/1475-925X-6-23</a>
In order to get the overall DFA (detrended fluctuation analysis),
compute this for a variety of window lengths, then plot that on a
log-log graph, and get the slope.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>np.array</em><em>, </em><em>[</em><em>T</em><em>, </em><em>]</em>) – waveform</p></li>
<li><p><strong>window_length</strong> (<em>int &gt; 0</em>) – L in the paper linked above. Length of windows for trend.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>average rmse for fitting lines on chunks of window lengths on the</dt><dd><p>cumulative sums of this signal.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="surfboard.dfa.get_dfa">
<code class="sig-prename descclassname">surfboard.dfa.</code><code class="sig-name descname">get_dfa</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">signal</span></em>, <em class="sig-param"><span class="n">window_lengths</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.dfa.get_dfa" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a signal, compute the DFA (detrended fluctuation analysis)
as per <a class="reference external" href="https://link.springer.com/article/10.1186/1475-925X-6-23">https://link.springer.com/article/10.1186/1475-925X-6-23</a>
See paper equations (13) to (16) for more information.</p>
</dd></dl>

<span class="target" id="module-surfboard.spectrum"></span><p>Spectrum features. The code in this file is inspired by audiocontentanalysis.org
For more details, visit the pyACA package: <a class="reference external" href="https://github.com/alexanderlerch/pyACA">https://github.com/alexanderlerch/pyACA</a></p>
<dl class="py function">
<dt id="surfboard.spectrum.get_spectral_centroid">
<code class="sig-prename descclassname">surfboard.spectrum.</code><code class="sig-name descname">get_spectral_centroid</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">magnitude_spectrum</span></em>, <em class="sig-param"><span class="n">sample_rate</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.spectrum.get_spectral_centroid" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the magnitude spectrum and the sample rate of the
waveform from which it came, compute the spectral centroid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>magnitude_spectrum</strong> (<em>np.array</em><em>, </em><em>[</em><em>n_frequencies</em><em>, </em><em>T / hop_length</em><em>]</em>) – the spectrogram</p></li>
<li><p><strong>sample_rate</strong> (<em>int</em>) – The sample rate of the waveform</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the spectral centroid sequence in Hz.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array [1, T / hop_length]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="surfboard.spectrum.get_spectral_flux">
<code class="sig-prename descclassname">surfboard.spectrum.</code><code class="sig-name descname">get_spectral_flux</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">magnitude_spectrum</span></em>, <em class="sig-param"><span class="n">sample_rate</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.spectrum.get_spectral_flux" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the magnitude spectrum and the sample rate of the
waveform from which it came, compute the spectral flux.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>magnitude_spectrum</strong> (<em>np.array</em><em>, </em><em>[</em><em>n_frequencies</em><em>, </em><em>T / hop_length</em><em>]</em>) – the spectrogram</p></li>
<li><p><strong>sample_rate</strong> (<em>int</em>) – The sample rate of the waveform</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the spectral flux sequence.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array [1, T / hop_length]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="surfboard.spectrum.get_spectral_kurtosis">
<code class="sig-prename descclassname">surfboard.spectrum.</code><code class="sig-name descname">get_spectral_kurtosis</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">magnitude_spectrum</span></em>, <em class="sig-param"><span class="n">sample_rate</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.spectrum.get_spectral_kurtosis" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the magnitude spectrum and the sample rate of the
waveform from which it came, compute the spectral skewness.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>magnitude_spectrum</strong> (<em>np.array</em><em>, </em><em>[</em><em>n_frequencies</em><em>, </em><em>T / hop_length</em><em>]</em>) – the spectrogram</p></li>
<li><p><strong>sample_rate</strong> (<em>int</em>) – The sample rate of the waveform</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the spectral kurtosis.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array [1, T / hop_length]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="surfboard.spectrum.get_spectral_skewness">
<code class="sig-prename descclassname">surfboard.spectrum.</code><code class="sig-name descname">get_spectral_skewness</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">magnitude_spectrum</span></em>, <em class="sig-param"><span class="n">sample_rate</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.spectrum.get_spectral_skewness" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the magnitude spectrum and the sample rate of the
waveform from which it came, compute the spectral skewness.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>magnitude_spectrum</strong> (<em>np.array</em><em>, </em><em>[</em><em>n_frequencies</em><em>, </em><em>T / hop_length</em><em>]</em>) – the spectrogram</p></li>
<li><p><strong>sample_rate</strong> (<em>int</em>) – The sample rate of the waveform</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the spectral skewness.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array [1, T / hop_length]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="surfboard.spectrum.get_spectral_slope">
<code class="sig-prename descclassname">surfboard.spectrum.</code><code class="sig-name descname">get_spectral_slope</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">magnitude_spectrum</span></em>, <em class="sig-param"><span class="n">sample_rate</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.spectrum.get_spectral_slope" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the magnitude spectrum and the sample rate of the
waveform from which it came, compute the spectral slope.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>magnitude_spectrum</strong> (<em>np.array</em><em>, </em><em>[</em><em>n_frequencies</em><em>, </em><em>T / hop_length</em><em>]</em>) – the spectrogram</p></li>
<li><p><strong>sample_rate</strong> (<em>int</em>) – The sample rate of the waveform</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the spectral slope sequence.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array [1, T / hop_length]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="surfboard.spectrum.get_spectral_spread">
<code class="sig-prename descclassname">surfboard.spectrum.</code><code class="sig-name descname">get_spectral_spread</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">magnitude_spectrum</span></em>, <em class="sig-param"><span class="n">sample_rate</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.spectrum.get_spectral_spread" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the magnitude spectrum and the sample rate of the
waveform from which it came, compute the spectral spread.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>magnitude_spectrum</strong> (<em>np.array</em><em>, </em><em>[</em><em>n_frequencies</em><em>, </em><em>T / hop_length</em><em>]</em>) – the spectrogram</p></li>
<li><p><strong>sample_rate</strong> (<em>int</em>) – The sample rate of the waveform</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the spectral spread (Hz).</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array [1, T / hop_length]</p>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-surfboard.misc_components"></span><p>This file contains components which do not fall under one category.</p>
<dl class="py function">
<dt id="surfboard.misc_components.get_bark_spectrogram">
<code class="sig-prename descclassname">surfboard.misc_components.</code><code class="sig-name descname">get_bark_spectrogram</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">waveform</span></em>, <em class="sig-param"><span class="n">sample_rate</span></em>, <em class="sig-param"><span class="n">n_fft_seconds</span></em>, <em class="sig-param"><span class="n">hop_length_seconds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.misc_components.get_bark_spectrogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a spectrogram to a bark-band spectrogram.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>waveform</strong> (<em>np.array</em><em>, </em><em>[</em><em>T</em><em>, </em><em>]</em>) – waveform over which to compute the bark
spectrogram.</p></li>
<li><p><strong>sample_rate</strong> (<em>int &gt; 0</em>) – number of samples per second in waveform.</p></li>
<li><p><strong>n_fft_seconds</strong> (<em>float &gt; 0</em>) – length of the fft window, in seconds</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>The original spectrogram</dt><dd><p>with bins converted into the Bark scale.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array, [n_bark_bands, t]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="surfboard.misc_components.get_crest_factor">
<code class="sig-prename descclassname">surfboard.misc_components.</code><code class="sig-name descname">get_crest_factor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">waveform</span></em>, <em class="sig-param"><span class="n">sample_rate</span></em>, <em class="sig-param"><span class="n">rms</span></em>, <em class="sig-param"><span class="n">frame_length_seconds</span><span class="o">=</span><span class="default_value">0.04</span></em>, <em class="sig-param"><span class="n">hop_length_seconds</span><span class="o">=</span><span class="default_value">0.01</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.misc_components.get_crest_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the crest factor of this waveform, on sliding windows. This value measures the local intensity
of peaks in a waveform. Implemented as per: <a class="reference external" href="https://en.wikipedia.org/wiki/Crest_factor">https://en.wikipedia.org/wiki/Crest_factor</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>waveform</strong> (<em>np.array</em><em>, </em><em>[</em><em>T</em><em>, </em><em>]</em>) – waveform over which to compute crest factor</p></li>
<li><p><strong>sample_rate</strong> (<em>int &gt; 0</em>) – number of samples per second in waveform</p></li>
<li><p><strong>rms</strong> (<em>np.array</em><em>, </em><em>[</em><em>1</em><em>, </em><em>T / hop_length</em><em>]</em>) – energy values.</p></li>
<li><p><strong>frame_length_seconds</strong> (<em>float</em>) – length of the sliding window, in seconds.</p></li>
<li><p><strong>hop_length_seconds</strong> (<em>float</em>) – how much the window shifts for every timestep,
in seconds.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Crest factor for each frame.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array, [1, T / hop_length]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="surfboard.misc_components.get_f0">
<code class="sig-prename descclassname">surfboard.misc_components.</code><code class="sig-name descname">get_f0</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">waveform</span></em>, <em class="sig-param"><span class="n">sample_rate</span></em>, <em class="sig-param"><span class="n">hop_length_seconds</span><span class="o">=</span><span class="default_value">0.01</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'swipe'</span></em>, <em class="sig-param"><span class="n">f0_min</span><span class="o">=</span><span class="default_value">60</span></em>, <em class="sig-param"><span class="n">f0_max</span><span class="o">=</span><span class="default_value">300</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.misc_components.get_f0" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the F0 contour using PYSPTK: <a class="reference external" href="https://github.com/r9y9/pysptk/">https://github.com/r9y9/pysptk/</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>waveform</strong> (<em>np.array</em><em>, </em><em>[</em><em>T</em><em>, </em><em>]</em>) – waveform over which to compute f0</p></li>
<li><p><strong>sample_rate</strong> (<em>int &gt; 0</em>) – number of samples per second in waveform</p></li>
<li><p><strong>hop_length</strong> (<em>int</em>) – hop size argument in pysptk.swipe. Corresponds to hopsize
in the window sliding of the computation of f0.</p></li>
<li><p><strong>method</strong> (<em>str</em>) – is one of ‘swipe’ or ‘rapt’. Define which method to use for f0
calculation. See <a class="reference external" href="https://github.com/r9y9/pysptk">https://github.com/r9y9/pysptk</a></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl>
<dt>Dictionary containing keys:</dt><dd><dl class="simple">
<dt>”contour” (np.array, [1, t1]): f0 contour of waveform. Contains unvoiced</dt><dd><p>frames.</p>
</dd>
<dt>”values” (np.array, [1, t2]): nonzero f0 values waveform. Note that this</dt><dd><p>discards all unvoiced frames. Use to compute mean, std, and other statistics.</p>
</dd>
</dl>
<p>”mean” (float): mean of the f0 contour.
“std” (float): standard deviation of the f0 contour.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="surfboard.misc_components.get_kurtosis_slidingwindow">
<code class="sig-prename descclassname">surfboard.misc_components.</code><code class="sig-name descname">get_kurtosis_slidingwindow</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">waveform</span></em>, <em class="sig-param"><span class="n">sample_rate</span></em>, <em class="sig-param"><span class="n">frame_length_seconds</span><span class="o">=</span><span class="default_value">0.04</span></em>, <em class="sig-param"><span class="n">hop_length_seconds</span><span class="o">=</span><span class="default_value">0.01</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.misc_components.get_kurtosis_slidingwindow" title="Permalink to this definition">¶</a></dt>
<dd><p>Same function as above, but decorated by the metric_slidingwindow decorator.
See above documentation for this.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>waveform</strong> (<em>np.array</em><em>, </em><em>[</em><em>T</em><em>, </em><em>]</em>) – waveform over which to compute the kurtosis array</p></li>
<li><p><strong>sample_rate</strong> (<em>int &gt; 0</em>) – number of samples per second in waveform</p></li>
<li><p><strong>frame_length_seconds</strong> (<em>float</em>) – length of the sliding window, in seconds.</p></li>
<li><p><strong>hop_length_seconds</strong> (<em>float</em>) – how much the window shifts for every timestep,
in seconds.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Kurtosis over windows</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array, [1, T/hop_length]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="surfboard.misc_components.get_log_energy">
<code class="sig-prename descclassname">surfboard.misc_components.</code><code class="sig-name descname">get_log_energy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">matrix</span></em>, <em class="sig-param"><span class="n">time_axis</span><span class="o">=</span><span class="default_value">- 1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.misc_components.get_log_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the log energy of a matrix as per Abeyrante et al. 2013.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>matrix</strong> (<em>np.array</em>) – matrix over which to compute. This
has to be a 1 or 2-dimensional np.array</p></li>
<li><p><strong>time_axis</strong> (<em>int &gt;= 0</em>) – the axis in matrix which corresponds
to time.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>The log energy of matrix, computed as per</dt><dd><p>the paper above.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="surfboard.misc_components.get_log_energy_slidingwindow">
<code class="sig-prename descclassname">surfboard.misc_components.</code><code class="sig-name descname">get_log_energy_slidingwindow</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">waveform</span></em>, <em class="sig-param"><span class="n">sample_rate</span></em>, <em class="sig-param"><span class="n">frame_length_seconds</span><span class="o">=</span><span class="default_value">0.04</span></em>, <em class="sig-param"><span class="n">hop_length_seconds</span><span class="o">=</span><span class="default_value">0.01</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.misc_components.get_log_energy_slidingwindow" title="Permalink to this definition">¶</a></dt>
<dd><p>Same function as above, but decorated by the metric_slidingwindow decorator.
See above documentation for this.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>waveform</strong> (<em>np.array</em><em>, </em><em>[</em><em>T</em><em>, </em><em>]</em>) – waveform over which to compute the log energy array</p></li>
<li><p><strong>sample_rate</strong> (<em>int &gt; 0</em>) – number of samples per second in waveform</p></li>
<li><p><strong>frame_length_seconds</strong> (<em>float</em>) – length of the sliding window, in seconds.</p></li>
<li><p><strong>hop_length_seconds</strong> (<em>float</em>) – how much the window shifts for every timestep,
in seconds.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>log_energy over windows</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array, [1, T/hop_length]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="surfboard.misc_components.get_loudness">
<code class="sig-prename descclassname">surfboard.misc_components.</code><code class="sig-name descname">get_loudness</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">waveform</span></em>, <em class="sig-param"><span class="n">sample_rate</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.misc_components.get_loudness" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the loudness of waveform using the pyloudnorm package.
See <a class="reference external" href="https://github.com/csteinmetz1/pyloudnorm">https://github.com/csteinmetz1/pyloudnorm</a> for more details on potential
arguments to the functions below.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>waveform</strong> (<em>np.array</em><em>, </em><em>[</em><em>T</em><em>, </em><em>]</em>) – waveform to compute loudness on</p></li>
<li><p><strong>sample_rate</strong> (<em>int &gt; 0</em>) – sampling rate of waveform</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the loudness of self.waveform</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="surfboard.misc_components.get_loudness_slidingwindow">
<code class="sig-prename descclassname">surfboard.misc_components.</code><code class="sig-name descname">get_loudness_slidingwindow</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">waveform</span></em>, <em class="sig-param"><span class="n">sample_rate</span></em>, <em class="sig-param"><span class="n">frame_length_seconds</span><span class="o">=</span><span class="default_value">0.04</span></em>, <em class="sig-param"><span class="n">hop_length_seconds</span><span class="o">=</span><span class="default_value">0.01</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.misc_components.get_loudness_slidingwindow" title="Permalink to this definition">¶</a></dt>
<dd><p>Same function as get_loudness, but decorated by the metric_slidingwindow decorator.
See get_loudness documentation for this.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>waveform</strong> (<em>np.array</em><em>, </em><em>[</em><em>T</em><em>, </em><em>]</em>) – waveform over which to compute the kurtosis array</p></li>
<li><p><strong>sample_rate</strong> (<em>int &gt; 0</em>) – number of samples per second in waveform</p></li>
<li><p><strong>frame_length_seconds</strong> (<em>float</em>) – length of the sliding window, in seconds.</p></li>
<li><p><strong>hop_length_seconds</strong> (<em>float</em>) – how much the window shifts for every timestep,
in seconds.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Frame level loudness</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array, [1, T / hop_length]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="surfboard.misc_components.get_ppe">
<code class="sig-prename descclassname">surfboard.misc_components.</code><code class="sig-name descname">get_ppe</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rat_f0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.misc_components.get_ppe" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute pitch period entropy. Here is a reference MATLAB implementation:
<a class="reference external" href="https://github.com/Mak-Sim/Troparion/blob/5126f434b96e0c1a4a41fa99dd9148f3c959cfac/Perturbation_analysis/pitch_period_entropy.m">https://github.com/Mak-Sim/Troparion/blob/5126f434b96e0c1a4a41fa99dd9148f3c959cfac/Perturbation_analysis/pitch_period_entropy.m</a>
Note that computing the PPE relies on the existence of voiced portions in the F0 trajectory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>rat_f0</strong> (<em>np.array</em>) – f0 voiced frames divided by f_min</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The pitch period entropy, as per <a class="reference external" href="http://www.maxlittle.net/students/thesis_tsanas.pdf">http://www.maxlittle.net/students/thesis_tsanas.pdf</a></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="surfboard.misc_components.get_shannon_entropy">
<code class="sig-prename descclassname">surfboard.misc_components.</code><code class="sig-name descname">get_shannon_entropy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sequence</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.misc_components.get_shannon_entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a sequence, compute the Shannon Entropy, defined in
<a class="reference external" href="https://ijssst.info/Vol-16/No-4/data/8258a127.pdf">https://ijssst.info/Vol-16/No-4/data/8258a127.pdf</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>sequence</strong> (<em>np.array</em><em>, </em><em>[</em><em>t</em><em>, </em><em>]</em>) – sequence over which to compute.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>shannon entropy.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="surfboard.misc_components.get_shannon_entropy_slidingwindow">
<code class="sig-prename descclassname">surfboard.misc_components.</code><code class="sig-name descname">get_shannon_entropy_slidingwindow</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">waveform</span></em>, <em class="sig-param"><span class="n">sample_rate</span></em>, <em class="sig-param"><span class="n">frame_length_seconds</span><span class="o">=</span><span class="default_value">0.04</span></em>, <em class="sig-param"><span class="n">hop_length_seconds</span><span class="o">=</span><span class="default_value">0.01</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.misc_components.get_shannon_entropy_slidingwindow" title="Permalink to this definition">¶</a></dt>
<dd><p>Same function as above, but decorated by the metric_slidingwindow decorator.
See above for documentation on this.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>waveform</strong> (<em>np.array</em><em>, </em><em>[</em><em>T</em><em>, </em><em>]</em>) – waveform over which to compute the shannon entropy array</p></li>
<li><p><strong>sample_rate</strong> (<em>int &gt; 0</em>) – number of samples per second in waveform</p></li>
<li><p><strong>frame_length_seconds</strong> (<em>float</em>) – length of the sliding window, in seconds.</p></li>
<li><p><strong>hop_length_seconds</strong> (<em>float</em>) – how much the window shifts for every timestep,
in seconds.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Shannon entropy over windows.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array, [1, T/hop_length]</p>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-surfboard.utils"></span><p>This file contains a variety of helper functions for the surfboard package.</p>
<dl class="py exception">
<dt id="surfboard.utils.YamlFileException">
<em class="property">exception </em><code class="sig-prename descclassname">surfboard.utils.</code><code class="sig-name descname">YamlFileException</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">message</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.utils.YamlFileException" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="surfboard.utils.example_audio_file">
<code class="sig-prename descclassname">surfboard.utils.</code><code class="sig-name descname">example_audio_file</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">which_file</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.utils.example_audio_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the path to one of sustained_a, sustained_o or sustained_e
included with the Surfboard package.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>which_file</strong> (<em>str</em>) – One of ‘a’, ‘o’ or ‘e’</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The path to the chosen file.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="surfboard.utils.lpc_to_lsf">
<code class="sig-prename descclassname">surfboard.utils.</code><code class="sig-name descname">lpc_to_lsf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">lpc_polynomial</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.utils.lpc_to_lsf" title="Permalink to this definition">¶</a></dt>
<dd><p>This code is inspired by the following:
<a class="reference external" href="https://uk.mathworks.com/help/dsp/ref/lpctolsflspconversion.html">https://uk.mathworks.com/help/dsp/ref/lpctolsflspconversion.html</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>lpc_polynomial</strong> (<em>list</em>) – length n + 1 list of lpc coefficients. Requirements
is that the polynomial is ordered so that lpc_polynomial[0] == 1</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>length n list of line spectral frequencies.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="surfboard.utils.max_peak_amplitude">
<code class="sig-prename descclassname">surfboard.utils.</code><code class="sig-name descname">max_peak_amplitude</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">signal</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.utils.max_peak_amplitude" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the maximum absolute value of a signal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>[</strong><strong>T</strong><strong>, </strong><strong>]</strong> (<em>np.array</em>) – a waveform</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the maximum amplitude of this waveform, in absolute value</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="surfboard.utils.metric_slidingwindow">
<code class="sig-prename descclassname">surfboard.utils.</code><code class="sig-name descname">metric_slidingwindow</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">frame_length</span></em>, <em class="sig-param"><span class="n">hop_length</span></em>, <em class="sig-param"><span class="n">truncate_end</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.utils.metric_slidingwindow" title="Permalink to this definition">¶</a></dt>
<dd><p>We use this decorator to decorate functions which take a sequence
as an input and return a metric (float). For example the sum of a sequence.
This decorator will enable us to quickly compute the metrics over a sliding
window. Note the existence of the implicit decorator below which allows us
to have arguments to the decorator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frame_length</strong> (<em>int</em>) – The length of the sliding window</p></li>
<li><p><strong>hop_length</strong> (<em>int</em>) – How much to slide the window every time</p></li>
<li><p><strong>truncate_end</strong> (<em>bool</em>) – whether to drop frames which are shorter than
frame_length (the end frames, typically)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>The function which computes the metric over sliding</dt><dd><p>windows.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>function</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="surfboard.utils.numseconds_to_numsamples">
<code class="sig-prename descclassname">surfboard.utils.</code><code class="sig-name descname">numseconds_to_numsamples</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">numseconds</span></em>, <em class="sig-param"><span class="n">sample_rate</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.utils.numseconds_to_numsamples" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a number of seconds a sample rate to the number of samples for n_fft,
frame_length and hop_length computation. Find the closest power of 2 for efficient
computations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>numseconds</strong> (<em>float</em>) – number of seconds that we want to convert</p></li>
<li><p><strong>sample_rate</strong> (<em>int</em>) – how many samples per second</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>closest power of 2 to int(numseconds * sample_rate)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="surfboard.utils.parse_component">
<code class="sig-prename descclassname">surfboard.utils.</code><code class="sig-name descname">parse_component</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">component</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.utils.parse_component" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse the component coming from the .yaml file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>component</strong> (<em>str</em><em> or </em><em>dict</em>) – Can be either a str, or a dictionary.
Comes from the .yaml config file. If it is a string,
simply return, since its the component name without arguments.
Otherwise, parse.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl>
<dt>tuple containing:</dt><dd><p>str: name of the method to be called from sound.Waveform
dict: arguments to be unpacked. None if no arguments to</p>
<blockquote>
<div><p>compute.</p>
</div></blockquote>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="surfboard.utils.peak_amplitude_slidingwindow">
<code class="sig-prename descclassname">surfboard.utils.</code><code class="sig-name descname">peak_amplitude_slidingwindow</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">signal</span></em>, <em class="sig-param"><span class="n">sample_rate</span></em>, <em class="sig-param"><span class="n">frame_length_seconds</span><span class="o">=</span><span class="default_value">0.04</span></em>, <em class="sig-param"><span class="n">hop_length_seconds</span><span class="o">=</span><span class="default_value">0.01</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.utils.peak_amplitude_slidingwindow" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the metric_slidingwindow decorator to the the peak amplitude computation defined above,
effectively computing frequency from fft over sliding windows.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>np.array</em><em> [</em><em>T</em><em>,</em><em>]</em>) – waveform over which to compute.</p></li>
<li><p><strong>sample_rate</strong> (<em>int</em>) – number of samples per second in the waveform</p></li>
<li><p><strong>frame_length_seconds</strong> (<em>float</em>) – how many seconds in one frame. This
value is defined in seconds instead of number of samples.</p></li>
<li><p><strong>hop_length_seconds</strong> (<em>float</em>) – how many seconds frames shift each step.
This value is defined in seconds instead of number of samples.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>peak amplitude on each window.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array, [1, T / hop_length]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="surfboard.utils.shifted_sequence">
<code class="sig-prename descclassname">surfboard.utils.</code><code class="sig-name descname">shifted_sequence</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sequence</span></em>, <em class="sig-param"><span class="n">num_sequences</span></em><span class="sig-paren">)</span><a class="headerlink" href="#surfboard.utils.shifted_sequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a sequence (say a list) and an integer, returns a zipped iterator
of sequence[:-num_sequences + 1], sequence[1:-num_sequences + 2], etc.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sequence</strong> (<em>list</em><em> or </em><em>other iteratable</em>) – the sequence over which to iterate
in various orders</p></li>
<li><p><strong>num_sequences</strong> (<em>int</em>) – the number of sequences over which we iterate.
Also the number of elements which come out of the output at each call.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>zipped shifted sequences.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>iterator</p>
</dd>
</dl>
</dd></dl>

<div class="toctree-wrapper compound">
</div>
</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="#">Surfboard</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="#">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Raphael Lenain.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.0.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>